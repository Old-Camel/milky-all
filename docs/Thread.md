# Thread

线程池是有效管理线程、高效使用服务器 CPU 资源的方式。jdk 本身提供了很优秀的线程池实现，并提供了诸多参数调整线程池的运行特性，但是线程池使用仍然会经历波折。

1. 监控。使用线程池经常会遇到线程池被打满的情况，为了排查问题，需要线程池能够向外输出线程池的监控数据。线程池本身是提供了回调接口和查询方法来获取线程池内部运行数据，但是需要额外的工作采集上报线程池监控数据。
2. 线程池参数。针对不同的使用特性调整线程池参数以满足任务需求是一个无法一步到位的工作，往往需要经历多轮的调整验证。打通动态线程池参数调整，配合线程池监控，可以让线程池参数设置真正地有据可依。
3. `Future` 增强。jdk 提供的 `Future` 缺少监听回调机制，缺少 `Future` 转换功能。
4. 线程池管理。应用中往往针对不同的任务会建立多个线程池，提供线程池的统一管理，涵盖线程池的创建、监控、关闭的全部生命周期。
5. 线程上下文。jdk 提供了 `ThreadLocal` 不仅可以解决多线程下的并发问题、还可以提供上下文传递的功能。但是在线程池中如何处理线程上下文的传递是一个问题。

## 线程池拒绝策略

Jdk 本身提供了 4 种线程池拒绝策略，除此之外一些优秀地开源软件也积累了一些优秀的拒绝策略实现。

1. 线程堆栈导出。`dubbo` 线程池对线程池拒绝策略做的增强，当检测到线程池被打满的时候会主动导出 jvm 线程堆栈。`dubbo` 这个功能做的有个很大的缺陷，缺少开启和关闭功能。因为这是个 `debug` 性质的功能，在生产环境上应尽量关闭 `debug` 功能。其次，在流量高峰期间线程池遭遇短时间内被打满是常有的事情，流量稍有下降即会自愈，这个导出 jvm 线程堆栈的过程会加剧高峰时刻 jvm 的压力，延缓自愈过程。
2. 强制等待。`elasticsearch` 提供的线程池拒绝策略。有很多时候线程池任务无法丢弃，必须保证任务执行，这个时候只能选择 `CallerRunsPolicy`，但是这个策略会阻断 `main` 线程任务的执行。`elasticsearch` 提供了强制执行等待策略，会持续等待线程池资源，直到任务提交成功。
3. 新建线程。`netty` 中提供的线程池策略。当遇到无法丢弃的任务时，会在拒绝时拉起一个新的线程执行这个任务，执行完毕后由 jvm 垃圾回收机制回收这个线程。
4. 提交超时等待。不会向 `elasticsearch` 那样无限等待，而是设置一个提交超时时间，超时时间内依然无法提交才会真正地拒绝这个任务。
5. 拒绝链或装饰器。比如在提交超时等待失败后如何对待这个任务，仍然可以选择其他策略。可以通过链式的拒绝策略，策略无法处理则交由下一个，直到被成功处理。或者采用装饰器对线程池拒绝策略进行增强，同时应用多种拒绝策略。

## 线程池参数

需要支持的参数如下：

1. 拒绝策略。需要能够动态调整线程池拒绝策略。
2. 池参数。核心线程数量，最大数量
3. 空白线程存活时间。超过核心线程数量在无任务时的存活时间。

## 上下文——`Map` & `Stack`



